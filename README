Гарантированно такой функционал реализуется только в одном случае: если мы можем
внести все сделанные изменения в ресурс атомарно.
Если изменяемых ресурсов больше одного, или хотя бы один из них не допускает 
атомарного внесения всех изменений, то об атомарности кода в целом можно говорить 
очень условно.

Все примеры используют в качестве ресурсов обычные файлы.

# ------------------------------------------------------------------------------
/One

Это самый простой вариант. Задействован только один ресурс (файл). В коде создаётся 
его копия, вся работа ведётся в ней, и потом изменённая копия за один вызов rename() 
замещает исходный файл. Исходим из того, что rename() - атомарная функция (на самом 
деле может быть и не так).

threads.pl, forks.pl

Примеры реализации многопоточных обработчиков.

# ------------------------------------------------------------------------------
/Many

Здесь каждая задача работает с двумя файлами. Структура:

AtomicTaskPP.pm

Базовый объект, обеспечивающий работу с задачами по модификации ресурсов. 
Унаследованные от него рабочие объекты должны перегружать только один метод execute(), 
который работает с реурсами, вся остальная работа выполняется здесь. В комментариях 
всё подробно описано.

Resource/Base.pm

Абстрактный базовый объект, описывающий ресурс для модификации. Унаследованные от него 
объекты должны перегружать соответствующие методы (см. подробные комментарии в исходнике).

Resource/File.pm

Полноценный (при желании расширяемый) объект Resource::File, реализующий все методы для
модификации файлов.

threads.pl, forks.pl

Примеры реализации многопоточных обработчиков. Task - производный от AtomicTaskPP объект
с перегруженным методом exeute(). 

# ------------------------------------------------------------------------------
 